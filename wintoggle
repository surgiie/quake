#!/usr/bin/env bash
display_logo() {
    YELLOW='\033[1;33m'
    NC='\033[0m'
    echo -e "${YELLOW}
█ █ █ █ █▄ █ ▀█▀ █▀█ █▀▀ █▀▀ █   █▀▀
▀▄▀▄▀ █ █ ▀█  █  █▄█ █▄█ █▄█ █▄▄ ██▄
    ${NC}"
}
VERSION="0.1.0"

cmd=""
window_name=""
on_activate=""
on_minimize=""
while [ $# -gt 0 ]; do
    case "$1" in
    --cmd | -c)
        cmd="$2"
        shift
        ;;
    --on-minimize | -m)
        on_minimize="$2"
        shift
        ;;
    --on-activate | -a)
        on_activate="$2"
        shift
        ;;
    --name | -n)
        window_name="$(echo $2 | xargs)"
        shift
        ;;
    --version | -v)
        echo "v$VERSION"
        exit 0
        ;;
    -h | --help)
        display_logo
        echo "Toggle a window in or out of the current active monitor."
        echo
        echo "Usage:"
        echo "    wintoggle [options]"
        echo "Options:"
        echo "    -n, --name                       The window process name to toggle as searchable by pgrep."
        echo "    -a, --on-activate                Run this command on activate of window."
        echo "    -m, --on-minimize                Run this command on minimize of window."
        echo "    -c, --cmd                        The command to execute that opens new window when its not running if different from window process name."
        echo "    -v, --version                    Display version information."
        echo "    -h, --help                       Display command help."
        exit 0
        ;;
    *)
        echo "Unknown argument or option: $1 (use --option value format)"
        exit 1
        ;;
    esac
    shift
done

if [[ -z "$window_name" ]]; then
    echo "❌ Error: window name is required via --name option."
    exit 1
fi

get_window_id() {
    local pattern="$1"
    pid="$(pgrep -o $pattern)"
    echo "$(wmctrl -lp | awk -v pid=$pid '$3 == pid {print $1}')"
}
wait_for_window() {
    local pattern="$1"
    local timeout="${2:-10}"   # seconds (default 10)
    local interval="${3:-0.2}" # polling interval (default 0.2s)

    local elapsed=0
    local id=""

    while (($(echo "$elapsed < $timeout" | bc -l))); do
        id=$(get_window_id "$pattern")
        echo "Waiting For Window: Process:$pattern | ID: $id | Backoff: $elapsed/$timeout"
        if [[ -n "$id" ]]; then
            echo "$id"
            return 0
        fi
        sleep "$interval"
        elapsed=$(echo "$elapsed + $interval" | bc -l)
    done
    if [[ ! -n "$id" ]]; then
        echo "Timed out waiting for window: $pattern"
        exit 1
    fi

    return 1 # timeout
}
run_hook() {
    local hook="$1"
    [[ -z "$hook" ]] && return 0
    echo "Running hook: $hook"
    bash -lc "$hook" || {
        echo "Hook failed: $hook" >&2
        return 1
    }
}
focus_window() {
    wid="$1"
    xdotool windowraise $wid
    eval $(xdotool getmouselocation --shell)
    xdotool windowmove "$wid" "$X" "$Y"
    xdotool windowactivate "$wid"
}

window_id="$(get_window_id $window_name)"
if [ -z "$window_id" ]; then

    if [ -z "$cmd" ]; then
        cmd="$window_name"
    fi

    if ! command -v $cmd 2>&1 >/dev/null; then
        echo "❌ Executable not found: $cmd"
        exit 1
    fi
    run_hook "$on_activate"
    bash -c "$cmd" >/dev/null 2>&1 &
    exit 0
fi

echo "Window Process Name: $window_name"
wait_for_window $window_name 15

echo "Window ID: $window_id"
state="$(xprop -id $window_id | grep -i '_net_wm_state(atom) = ')"
echo "Window State: $state"
if [[ ${state,,} == *"_net_wm_state_hidden"* ]]; then
    echo "Window Action: Activate"
    focus_window $window_id
    run_hook "$on_activate"

else
    if [[ ${state,,} == *"_net_wm_state_maximized"* ]]; then
        echo "Widow Action: Activate"
        focus_window "$window_id"
        run_hook "$on_activate"
    else
        echo "Window Action: Hide"
        xdotool windowminimize "$window_id"
        run_hook "$on_minimize"
    fi
fi
